# **Chat Service / Draft v1**

## Overview

The Chat Service is a small NestJS service in charge of providing a communication gateway between the users of a web application. The main channel of communication for this service is WebSocket and more specifically the SocketIO's framework; however, it also relies on a couple of REST API Endpoints for authentication.

The following list of features is implemented:
- A simple user registration requiring only the name of the user to issue a new token
- User authorization based on the token generated
- Providing users with the total number of online users
- Ability to send a new message by each user
- Ability to reply to a message by another user
- Ability to mute a user to no longer receive any messages from
- Sends a sample system chat message each 5 minutes
- Notify connected clients of changes to the number of online users each minute
- In memory persistence of messages, users, and muted users for as long as the service is running

 
## Messages

A chat message represents a new entry in the chat that transmitted a message from one user to the rest of the users subscribed to the chat.
Each message contains information about the person who sent it and might also reference another older message. Therefore, to send a message, the user must be authenticated with the service.

Upon joining chat, a limited list of last messages is sent back to be used by the client. 


## System messages

A message without `user` property is considered a system message. These sorts of messages can be used to notify users of the rules of the chat or any other information that the owner decides.


## Muted users

A user of the chat can mute another user. This operation ensures that the user that requested this operation, will not receive messages from the user they muted.

To mute another user, the user must first authenticate with the service.

Please note that muted users are not filtered via the Chat Service when receiving a message and are rather expected to get filtered by the client when receiving a message from such a user or rendering a message.


## Registration

The registration process for this service is simple and only requires a name for a client to get a token. This token can later be used for other operations that require a logged-in user to function.


## Authentication

Authentication is done simply using a JWToken generated by the registration process. This token contains a user identification number, the name provided as part of the registration process, and an avatar url to be used by the client for rendering proposes. There is no authorization involved meaning that all users have the same access to the functionalities provided by the service.

Following are the expected JWT payload - claims:

```typescript
{
  "iss": string;    // Domain name, e.g. example.com
  "exp": number;    // Expiry timestamp
  "iat": number;    // Issue Timestamp 
  "sub": number;    // User Id, e.g. 10
  "uid": number;    // User Id, e.g. 10
  "avatar": string; // User Avatar, e.g.
  "name": string;   // User Name, e.g. John Doe
}
```

## Communication

Communication with actual users of the web application is mainly done via SocketIO v2. However, registration is done over HTTP and via a REST endpoint.

A `Firecamp.json` file accompanies this document that contains information about the request structure and values of each of the REST endpoints or WebSocket messages. This file can be imported into the Firecamp application to get an elementary idea about each of these endpoints and messages.

### REST
Two endpoints exist that are used to register a new user and to get information about the currently logged-in user. Both these endpoints are located at the `/auth/me` address and will be discussed in detail below.

The authentication token is passed as `Bearer` via the `Authorization` header for endpoints that require a logged-in user to function.

Swagger documentation is also available at the `/swagger` address when Chat Service is started in the development environment.

Following is the list of all endpoints available on this version of the service with detailed information about the request and response type of each:

- **Register - [POST] `/auth/me`** (Access: Everyone)

  Used for registration of a new user and generation and signing of the toke and expect a request body of type `RegisterDto` containing the following list of properties:

  ```typescript
  {
    user_name: string;  // The user's choosen username, composed of english letter and numbers (starting with a letter) and without any space
  }
  ```

  The response body of this request is of type `AuthenticationTokenDto` and contains the following list of properties:

  ```typescript
  {
    token: string; // The issued and signed JWToken
    user: MeDto;   // The current user's information, will be discussed later
  }
  ```

- **Query User - [GET] `/auth/me`** (Access: Users)

  Returns information about the currently logged-in user. The response to this request is of type `MeDto` and contains the following properties:

  ```typescript
  {
    user_id: number;      // The user's identification number
    user_name: string;    // The user's username
    user_avatar: string;  // The user's avatar url
    created: string;      // The user's registration date in ISO 8601 format
  }
  ```

  `MeDto` is an extension of the `UserDto` and adds a new property named `created` of type `string` that contains the user's registration date in ISO 8601 format.
  
  `UserDto` itself is defined as below:
  ```typescript
  {
    user_id: number;      // The user's identification number
    user_name: string;    // The user's username
    user_avatar: string;  // The user's avatar url
  }
  ```

### WebSocket
WebSocket connection is made to the `/ws` path via the Socket.IO v2 and without pulling. The authentication token for this service is optional, however, it is required to be present when sending a new message or muting a user. The token is passed via the `jwt` query string.

Messages are separated into two categories, **RPC** messages and **Notify** messages. RPC messages are messages that are sent via the client to the server and require a response. To be able to do so, each RPC message must contain a unique key that is going to be included in the resulting response. The response to an RPC message is sent via a message of the same name postfixed with `_RESULT`. In case of an exception or error, a separate message called `exception` is sent that contains the same key used in the request. Notify messages on the other hand don't have such a property and don't require an immediate response from the server. In the current draft of the Chat Service, all client-initiated messages are RPC and all messages sent by the server are of type Notify except the ones responding to an RPC message.

Every RPC request extends the `WsRPCRequestDto` type that contains a single property named `key` of type `string`. The client can use an increasing number for each request or simply use a randomly generated UUID for the `key` of an RPC request as there is no limitation for the value of this property in place except that it should be less than or equal to 64 characters in length.

The response of each RPC request is wrapped in type `WsRPCResponseDto` that contains the following list of properties:
```typescript
{
  status_code: number;  // Similiar to the HTTP status code, contains a number indicating the type of response recieved
  message: string;      // Similiar to the HTTP status, contains a phrase describing the type of response recieved
  key: string;          // Contains the same key used in the correspanding request
  result: Object;       // Contains the actual response of the RPC message, the type of this property depends on the type of the response expected from the RPC message sent
}
```

In case of exceptions, the payload of the `exception` message for RPC messages is of type `WsRPCExceptionDto` and contains the following list of properties:
```typescript
{
  status_code: number;  // Similiar to the HTTP status code, contains a number indicating the type of response recieved
  message: string;      // Similiar to the HTTP status, contains a phrase describing the type of response recieved
  key: string;          // Contains the same key used in the correspanding request
  error: string;        // Contains the actual message of the error, can be used to notify user of the reason behind the failure or logged in one way or another
  error_code?: string;  // Contains an optional error code reported by the method raising this error, only available for service exception, a service exception is a custom exception that simply contains an error code
}
```

Due to a couple of technical limitations, the client should continue the connection initiation process with client registration by first sending a `CHAT_JOIN` message. This is to allow the NestJS guards to parse and extract the token from the query string of the handshake connection.

Following is the list of messages that are used by the client or the server to notify the other side or to perform an action:

- **Client Registration - `CHAT_JOIN`** (Access: Everyone, Type: RPC, Initiator: Client) 

  Is used by the client to register itself as a user in the chat service and contains a payload of type `WsChatJoinDto` extending the `WsRPCRequestDto` type but not having any additional properties.

  The response of this RPC message (which is sent as a `CHAT_JOIN_RESULT` message) is of type `WsChatJoinedDto` and is wrapped inside of a `WsRPCResponseDto` instance (`WsChatJoinedDto` extends `WsChatStatusDto` that will be discussed later). `WsChatJoinedDto` contains the following list of properties:
  ```typescript
  {
    last_message: string | null;        // Contains the date and time of the last message sent to chat, or `null` of no message is yet recieved by the Chat Service
    users: number; // Contains the number of connected clients to the Chat Service
    messages: WsChatMessageDto[];       // Contains the list of last messages sent to the chat used by the client to render the chat's message panel. The type of this property will be discussed later
    muted_users: WsChatUserMutedDto[];  // Contains the list of muted users by the current logged in user, and therefore empty of user is not logged in; used by the client to filter recieved messages and to allow the current user to unmute a user. The type of this property will be discussed later
  }
  ```

- **Chat Status Updated - `CHAT_STATUS`** (Access: Users, Type: Notify, Initiator: Server)

  This is a broadcast message from the Chat Service to all connected sockets and is triggered periodically to update clients about the current status of the Chat Service. The payload of this message is of type `WsChatStatusDto` and contains the following list of properties:
  ```typescript
  {
    last_message: string | null;  // Contains the date and time of the last message sent to chat, or `null` of no message is yet recieved by the Chat Service
    users: number;                // Contains the number of connected clients to the Chat Service
  }
  ```

  As you can see, this type contains a subset of `WsChatJoinedDto`'s properties and therefore indicate that `WsChatJoinedDto` is a child of this type.

- **New Message Arrived - `CHAT_MESSAGE`** (Access: Everyone, Type: Notify, Initiator: Server) 

  This is a broadcast message from the Chat Service to all connected sockets and is triggered when a new message is sent by any of the users. The payload of this message is of type `WsChatMessageDto` that extends the `WsChatMessageReplyToDto` type and contains the following resulting list of properties:
  ```typescript
  {
    id: number;                               // The message's identification number
    user: UserDto | null;                     // Contains information about the user who sent this message, described above
    message: string;                          // Contains the body of the message
    date: string;                             // Contains the date and time at which this message was sent in ISO 8601 format
    reply_to: WsChatMessageReplyToDto | null; // Contains the message that this new message is a reply to, or `null` if this isnt a reply message. The type of this property will be discussed later
  }
  ```

  `WsChatMessageReplyToDto` itself contains the following list of properties:
  ```typescript
  {
    id: number;           // The message's identification number
    user: UserDto | null; // Contains information about the user who sent this message, described above
    message: string;      // Contains the body of the message
    date: string;         // Contains the date and time at which this message was sent in ISO 8601 format
  }
  ```

  As it should be obvious, every property of `WsChatMessageDto` except the `reply_to` property is extended from the `WsChatMessageReplyToDto` type. 

  Another point to consider is that system messages lack a value for the `user` property. These are messages that are sent via the service for informational purposes and are not created by any specific user.

- **Muted Users Updated - `CHAT_MUTED_USERS`** (Access: Users, Type: Notify, Initiator: Server)

  This is another broadcast message by the Chat Service sent to all sockets of a logged-in user when the list of muted users is changed. 
  
  The payload of this message is an `array` of type `WsChatUserMutedDto`. `WsChatUserMutedDto` extends the `UserDto` and adds a single `muted` property of type `string` that contains the date and time at which this user is muted in ISO 8601 format. When a user is not in the list, it should no longer be considered muted.

- **Send New Message - `CHAT_SEND_MESSAGE`** (Access: Everyone, Type: RPC, Initiator: Client)

  `CHAT_SEND_MESSAGE` is an RPC message initiated by the client to send a new message to chat. The payload of this message is of type `WsChatMessageSendDto`, extending the `WsRPCRequestDto` type, and contains the following additional properties:
  ```typescript
  {
    message: string;    // The body of the message to send
    reply_to?: number;  // The identification number of the message that this message replies to
  }
  ```

  The response to this request is sent via a new `CHAT_SEND_MESSAGE_RESULT` message and contains a payload of type `WsChatMessageDto` that is wrapped inside of a `WsRPCResponseDto` instance.

- **Mute and Unmute a User - `CHAT_MUTE`** (Access: Users, Type: RPC, Initiator: Client)

  `CHAT_MUTE` is an RPC message sent by the client to the Chat Service to save a user as muted or to unmute an already muted user. 
  
  Like other RPC messages, the payload of this message extends the `WsRPCRequestDto` type. Payload is of type `WsChatUserMuteDto` and contains the following list of additional properties:
  ```typescript
  {
    user_id: number;  // The identification number of the user to be muted or unmuted
    mute: boolean; // A boolean value indicating if this user has to be muted or unmuted
  }
  ```

  The response to this message is a `boolean` value indicating if the process is completed successfully, is sent via a separate `CHAT_MUTE_RESULT` message, and is wrapped inside of a `WsRPCResponseDto` instance.

## How to Run
To start the service in development mode you must:

* Install dependencies via `npm install`
* Run application in development mode via `npm run start:dev`

`start:prod` can be used instead of `start:dev` to run the application in development mode. However, to do so you first need to run the `npm run build` to convert all TypeScript files to JavaScript allowing the service to run directly.

The configurations for this service are available via a couple of `.yaml` files located in the `config` folder, one for each environment. But, it is also possible to modify these configurations via the environmental variables; to do so we just have to create a new `.env` file and fill it with the required values. Follow the `.env.example` for information about how this file should be formatted and what configurations are valid.

A `Dockerfile` is also included with the project allowing it to be built and pushed to a repository to be started on a Docker instance. Doing so also allows us to send the JWT token as a Docker Secret by mapping it to a file and sending the address of the file as an environment variable named `JWT_SECRET_KEY_FILE` to the service.


## Change Log
* 12/05/2021 - First Draft